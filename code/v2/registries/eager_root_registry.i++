namespace KHJ  {
  namespace thesis  {
    namespace root_registry  {
      /**
       * Constructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      eager_root_registry<N, M, S>::eager_root_registry( )
      { }

      /**
       * DeConstructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      eager_root_registry<N, M, S>::~eager_root_registry( ) 
      { }
      
      /**
       * top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      N* eager_root_registry<N, M, S>::top( ) const
      { 
        return root_table_.top; 
      }

      /**
       * size( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      int eager_root_registry<N, M, S>::size( ) const
      { 
        return root_table_.size( ); 
      }

      
      /**
       * insert( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void eager_root_registry<N, M, S>::insert( N* Q )
      { 
        if( root_table_.top == nullptr || 
            modifier_type::compare_( (*Q).element(), (*root_table_.top).element() ) ) { 
          root_table_.top = Q; 
        } 
        
        root_table_.push_front( Q );
      }

      /**
       * extract( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      N* eager_root_registry<N, M, S>::extract( )
      { 
        N* B = nullptr;               
        for( auto it = root_table_.begin( ) ; it != root_table_.end( ) ; it++ ) {
          if( !it->empty( )) {
            B = root_table_.extract( it );
            if( B->height( ) != 0 ) {
              N** st = modifier_type::split( B );
              root_table_.insert( --it, st[0] ); root_table_.insert( it, st[1] );
              if( it->size( ) >= 3 ) { fix_( it ); } 
              delete[] st;
            }
            break;
          }
        }
        if( (*B).element( ) == (*root_table_.top).element( ) ) {
          modifier_type::siftup( root_table_.top );
          root_table_.top = B;
        }
        return B;
      }
       
      /**
       * consolidate( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void eager_root_registry<N, M, S>::consolidate( )
      { 
        if( (*root_table_.begin( )).size( ) == 3 )
          hi_.push_back( root_table_.begin( ) ); 
        while( 1 ) {
          if( !hi_.empty( ) ) {
            iterator_type I = hi_.back( ); hi_.pop_back( );
            fix_( I );
          } else {
            break;
          }
        }        
      }

      /**
       * update_top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void eager_root_registry<N, M, S>::update_top( )
      {
        root_table_.top = nullptr;
        for( auto it = root_table_.begin( ) ; it != root_table_.end( ) ; it++ ) {
          for( auto vit = (*it).begin( ) ; vit != (*it).end( ) ; vit++ ) {
            if( root_table_.top == nullptr || 
                modifier_type::compare_( (*(*vit)).element(),  (*root_table_.top).element() ) )  {          
              root_table_.top = *vit;
            }
          }
        }
      }
       
      template<typename N, typename M, typename S>
      void eager_root_registry<N, M, S>::print( ) const
      {
        root_table_.print( );
        if( root_table_.top != nullptr ) {
          std::cout << "top: " << (*root_table_.top).element( ) << std::endl;
        }
      }

      template <typename N, typename M, typename S>
      void eager_root_registry<N, M, S>::fix_( iterator_type I )
      { 
        iterator_type E = std::next( I );  
        iterator_type W = std::prev( I );
        
        if( E == root_table_.end( ) ) { root_table_.grow( ); --E; }
        
        N* Q = root_table_.extract( I );
        N* R = root_table_.extract( I );
        N* V = root_table_.extract( I );
        
        N* t[3] = { Q, R, V };     
        swap_nodes_( t, 0, modifier_type::compare_( (*t[1]).element(), (*t[0]).element() ) );
        swap_nodes_( t, 2, modifier_type::compare_( (*t[0]).element(), (*t[2]).element() ) );
        
        if( I != root_table_.begin( ) ) {
          N** st = modifier_type::split( t[0] );
          modifier_type::join_heaps( t[0], t[1], t[2]  ); root_table_.insert( E, t[0]  );
          root_table_.insert( W, st[0] ); root_table_.insert( W, st[1] );
          delete[] st;
        } else {
          modifier_type::join_heaps( t[0], t[1], t[2]  ); root_table_.insert( E, t[0] );
        }
        if( E->size( ) == 3 ) { hi_.push_back( E ); }
      }

      // swap aux
      template <typename N, typename M, typename S>
      void eager_root_registry<N, M, S>::swap_nodes_ (N* nodes[], int i1, int i2) 
      {
        N* temp   = nodes[i1];
        nodes[i1] = nodes[i2];
        nodes[i2] = temp;
      }
    }
  }
}
