namespace KHJ  {
  namespace thesis  {
    namespace registry  {
      /**
       * Constructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      root_registry<N, M, S, J>::root_registry( ) : policy_( store_ )
      { }

      /**
       * DeConstructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      root_registry<N, M, S, J>::~root_registry( ) 
      { }
      
      /**
       * top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      N* root_registry<N, M, S, J>::top( ) const
      { 
        return store_.top; 
      }
      
      /**
       * insert( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::insert( N* Q )
      { 
        if( store_.top == nullptr || modifier_type::compare_( *Q, *store_.top ) ) { store_.top = Q; 
        }
        store_.push_front( Q );
        policy_.consolidate( );  
      }
      
      /**
       * extract( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      N* root_registry<N, M, S, J>::extract( N* Q )
      { 
        N* B = policy_.borrow( );
        modifier_type::replace( Q, B );
        modifier_type::siftup_( B ); 
        modifier_type::siftdown_( B );
                
        for( auto it = store_.begin( ) ; it != store_.end( ) ; it++ ) {
          for( auto vit = (*it).begin( ) ; vit != (*it).end( ) ; vit++ ) {
            if( !(*vit)->is_root( ) ) {
              *vit = (*vit)->find_root();
            } else if( (*vit) == Q  ) {
              *vit = B->find_root(); 
            }
          }
        }
        // only if top is replaced!
        //top_ = nullptr;
        if( Q == store_.top ) { 
          store_.top = nullptr;
          for( auto it = store_.begin( ) ; it != store_.end( ) ; it++ ) {
            for( auto vit = (*it).begin( ) ; vit != (*it).end( ) ; vit++ ) {
              if( store_.top == nullptr || modifier_type::compare_( (*(*vit)),  (*store_.top)  ))  {          
                store_.top = (*vit);
              }
            }
          }
        }
        return Q;
      }
       
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::print( ) const
      {
        store_.print( );
        std::cout << "top: " << (*store_.top).element( ) << std::endl;
      }
    }
  }
}
