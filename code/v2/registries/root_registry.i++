#include <memory>
#include "heap_utils.h++"
namespace KHJ  {
  namespace thesis  {
    namespace registry  {
      /**
       * Constructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      root_registry<N, M, S, J>::root_registry( ) : top_( nullptr )
      { 
        state_.reserve( 2 );
        state_[0] = store_.begin( );
        state_[1] = std::next( state_[0] );
        
        join_policy_.push_lo( store_.begin( ) );
      }

      /**
       * DeConstructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      root_registry<N, M, S, J>::~root_registry( ) 
      { }
      
      /**
       * top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      N* root_registry<N, M, S, J>::top( ) const
      { 
        return top_; 
      }
      
      /**
       * insert( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::insert( N* Q )
      { 
        if( top_ == nullptr || modifier_type::compare_( *Q, *top_ ) ) { top_ = Q; 
        }
        store_.push_front( Q );
        
        if( (*store_.begin( )).size( ) == 2 ) { join_policy_.pop_lo(  ); 
        } 
        if( (*store_.begin( )).size( ) == 3 ) { join_policy_.push_hi( store_.begin( ) ); 
        } 
        
        cons_list L = join_policy_.join_list_hi( );
        for( auto it = L.begin( ); it != L.end(); ++it) {
          fix_( *it );
        }
      }
      
      /**
       * extract( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      N* root_registry<N, M, S, J>::extract( N* Q )
      { 
        N* B = borrow_( );
        
        modifier_type::replace( Q, B );
        modifier_type::siftup_( B ); 
        modifier_type::siftdown_( B );
       
        // should be abstracted into storage
        for( auto it = store_.begin( ) ; it != store_.end( ) ; it++ ) {
          for( auto vit = (*it).begin( ) ; vit != (*it).end( ) ; vit++ ) {
            if( !(*vit)->is_root( ) ) {
              *vit = (*vit)->find_root();
            } else if( (*vit) == Q  ) {
              *vit = B->find_root(); 
            }
          }
        }
     
        top_ = nullptr;
        for( auto it = store_.begin( ) ; it != store_.end( ) ; it++ ) {
          for( auto vit = (*it).begin( ) ; vit != (*it).end( ) ; vit++ ) {
            if( top_ == nullptr || modifier_type::compare_( (*(*vit)),  (*top_)  ))  {          
              top_ = (*vit);
            }
          }
        }     
        return Q;
      }
 
      /**
       * fix_()
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::fix_( iterator_type I )
      { 
        if( std::next( I ) == store_.end( ) ) { store_.grow( ); }
        
        iterator_type E = std::next( I );  
        iterator_type W = std::prev( I );
        
        if( E == store_.end( ) ) { store_.grow( ); }

        N* Q = store_.extract( I );
        N* R = store_.extract( I );
        N* V = store_.extract( I );
        
        N* t[3] = { Q, R, V };     
        swap_nodes_( t, 0, modifier_type::compare_( *t[1], *t[0] ) );
        swap_nodes_( t, 2, modifier_type::compare_( *t[0], *t[2] ) );
        
        if( W != store_.end( ) ) {
          std::unique_ptr<N*[]> st = modifier_type::split( t[0] );
          modifier_type::join_heaps( t[0], t[1], t[2]  ); store_.insert( E, t[0]  );
          
          if( W->size( ) <= 1 ) { join_policy_.pop_lo( ); }
          update_lo_( E );
          
          store_.insert( W, st[0] ); store_.insert( W, st[1] );
          if( W->size( ) >= 3 ) { join_policy_.push_hi( W ); }
        } else {
          modifier_type::join_heaps( t[0], t[1], t[2]  ); store_.insert( E, t[0] );
          update_lo_( E );
        }
        join_policy_.push_lo( I );
      }

      /**
       * unfix_()
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::unfix_( iterator_type I )
      { 
        iterator_type E = std::next( I );
        iterator_type W = std::prev( I );
        
        N* P = store_.extract( E );
        
        std::unique_ptr<N*[]> st = modifier_type::split( P );
        
        
        E->empty( );
        
        if( E->empty( ) && E == store_.last( ) ) {
        
          join_policy_.pop_lo( ); store_.shrink( );
        } else {
        
          if( E->size( ) == 1 ) {
            join_policy_.push_lo( E );
          } else if( E->size( ) == 2 ){
            join_policy_.pop_hi( );
          }
        }
        if( W != store_.end( ) ) {
          if( W->size() >= 3 ) { join_policy_.pop_hi( ); }

          N* Q = store_.extract( W );
          N* R = store_.extract( W );
          if( W->size() <= 1 && W != store_.begin( ) ) { join_policy_.push_lo( W ); }
          modifier_type::join_heaps( P, Q, R  );
          modifier_type::siftdown_( P );

          if( !(P->is_root( )) ) { P = P->find_root( ); }
        }

        store_.insert( I, P );
        store_.insert( I, st[0] );
        store_.insert( I, st[1] );

        join_policy_.push_hi( I );       
      }

      /**
       * Borrow( ).
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      N* root_registry<N, M, S, J>::borrow_( )
      { 
        N* B;
        iterator_type I = store_.begin( );
        
        if( !in_idle_state_( ) && !join_policy_.lo_empty( ) ) {
          if( state_[0]->size( ) == 2 && state_[1]->size( ) == 2) {
            if( !join_policy_.hi_empty( ) && 
                join_policy_.get_hi( join_policy_.hi_size( ) - 1 )->size( ) == 3 ) {
              cons_list L = join_policy_.join_list_lo( );
              for( auto it = L.begin( ); it != L.end(); ++it) {
        
                unfix_( *it );
              }
            }
          } else {
            cons_list L = join_policy_.join_list_lo( );
            for( auto it = L.begin( ); it != L.end(); ++it) {
              unfix_( *it );
            }
          }
        }
        B = store_.extract( I );
        if( !(I->empty( )) && I->size( ) == 2 ) { join_policy_.pop_hi( );
        } else if( ( I->empty( ) || ( !I->empty() && I->size( ) == 1 )) && 
                   ( join_policy_.get_lo( join_policy_.lo_size( ) - 1) != I) ) {
          join_policy_.push_lo( I );
        }
        
        return B;
      }

      template<typename N, typename M, typename S, typename J>
      bool root_registry<N, M, S, J>::in_idle_state_( ) const
      { 
        // idle state 21t
        if( state_[0]->size() == 2 && state_[1]->size() == 1) {
          return true;
        } else if( state_[0]->size() == 1 && state_[1]->size() == 2) {
          if( !join_policy_.hi_empty( ) ) {
            return false;
          } else {
            if( join_policy_.lo_size( ) == 1 || 
                join_policy_.get_lo( join_policy_.lo_size( ) - 2 ) == store_.last( ) ) {
              return true;
            } else {
              return false;
            }
          }
        } else {
          return false;
        }
      }

      // swap aux
      template <typename N, typename M, typename S, typename J>
      void  root_registry<N, M, S, J>::swap_nodes_ (N* nodes[], int i1, int i2) {
        N* temp   = nodes[i1];
        nodes[i1] = nodes[i2];
        nodes[i2] = temp;
      }

      template <typename N, typename M, typename S, typename J>
      void  root_registry<N, M, S, J>::update_lo_( iterator_type E ) {
        if( E->size( ) == 1 && join_policy_.lo_empty( ) ) { join_policy_.push_lo( E );
        } else if( E->size( ) == 2 ) { join_policy_.pop_lo( ); 
        } else if( E->size( ) == 3 ) { join_policy_.push_hi( E ); } }

      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::print( ) const
      {
        store_.print( );
        std::cout << "top: " << (*top( )).element( ) << std::endl;
        std::cout << "state: " << (state_[0])->size( ) << (state_[1])->size( ) << std::endl;
        join_policy_.print( );
      }
    }
  }
}
