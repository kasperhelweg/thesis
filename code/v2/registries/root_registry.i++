#include <memory>
namespace KHJ  {
  namespace thesis  {
    namespace registry  {
      
      /**
       * Constructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      root_registry<N, M, S>::root_registry( ) 
      { }

      /**
       * DeConstructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      root_registry<N, M, S>::~root_registry( ) 
      { }
      
      /**
       * top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void root_registry<N, M, S>::top( ) const
      { 
        return store_.top( );
      }
      
      /**
       * insert( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void root_registry<N, M, S>::insert( N* Q )
      { 
        join_schedule L = store_.push_front( Q );
        for( auto it = L.begin( ); it != L.end(); ++it) {
          fix_( *it );
        }
        //store_.print( );
      }

      /**
       * extract( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      N* root_registry<N, M, S>::extract( )
      { 
      }
 
      /**
       * fix_()
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void root_registry<N, M, S>::fix_( accessor_type I )
      { 
        accessor_type E = std::next( I );  // should be abstracted
        accessor_type W = std::prev( I );  // should be abstracted
        
        N* Q = store_.extract( I );
        N* R = store_.extract( I );
        N* V = store_.extract( I );
        
        N* t[3] = { Q, R, V };     
        swap_nodes_( t, 0, modifier_type::compare_( *t[1], *t[0] ) );
        swap_nodes_( t, 2, modifier_type::compare_( *t[0], *t[2] ) );
        
        if( store_.is_valid( W ) ) {
          std::unique_ptr<N*[]> st = modifier_type::split( t[0] );
          modifier_type::join_heaps( t[0], t[1], t[2]  );
          store_.insert( E, t[0]  );
          
          if( store_.size_of( W ) <= 1 ) { store_.pop_lo( ); }
          update_lo_( E );
          
          store_.insert( W, st[0] ); store_.insert( W, st[1] );
          if( store_.size_of( W ) >= 3 ) { store_.push_hi( W ); }
        } else {
          modifier_type::join_heaps( t[0], t[1], t[2]  );
          store_.insert( E, t[0] );
                    
          update_lo_( E );
        }
        store_.push_lo( I );
      }

      /**
       * unfix_()
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void root_registry<N, M, S>::unfix_( )
      { }

      // swap aux
      template <typename N, typename M, typename S>
      void  root_registry<N, M, S>::swap_nodes_ (N* nodes[], int i1, int i2) {
        N* temp   = nodes[i1];
        nodes[i1] = nodes[i2];
        nodes[i2] = temp;
      }

      template <typename N, typename M, typename S>
      void  root_registry<N, M, S>::update_lo_ ( accessor_type E ) {
        if( store_.size_of( E ) == 1 && store_.lo_empty( )  ) { 
          //P.push_lo( E ); 
        } else if( store_.size_of( E ) == 2 ) { 
          //P.pop_lo( ); 
        } else if( store_.size_of( E ) == 3 ) { store_.push_hi( E ); }
      }

      template<typename N, typename M, typename S>
      void root_registry<N, M, S>::print( ) const
      {
        store_.print( );
      }

    }
  }
}
