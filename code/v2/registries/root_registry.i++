#include <memory>
namespace KHJ  {
  namespace thesis  {
    namespace registry  {
      
      /**
       * Constructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      root_registry<N, M, S, J>::root_registry( ) 
      { }

      /**
       * DeConstructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      root_registry<N, M, S, J>::~root_registry( ) 
      { }
      
      /**
       * top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::top( ) const
      { 
        return store_.top( );
      }
      
      /**
       * insert( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::insert( N* Q )
      { 
        store_.push_front( Q );

        //cons_list L = store_.push_front( Q );
        if( (*store_.begin( )).size( ) == 3 ) { join_policy_.push_hi( store_.begin( ) ); 
        } 
        cons_list L = join_policy_.join_list( );
        for( auto it = L.begin( ); it != L.end(); ++it) {
          fix_( *it );
        }
        //store_.print( );
      }

      /**
       * extract( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      N* root_registry<N, M, S, J>::extract( )
      { 
      }
 
      /**
       * fix_()
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::fix_( iterator_type I )
      { 
        iterator_type E = std::next( I );  
        iterator_type W = std::prev( I );
        
        N* Q = store_.extract( I );
        N* R = store_.extract( I );
        N* V = store_.extract( I );
        
        N* t[3] = { Q, R, V };     
        swap_nodes_( t, 0, modifier_type::compare_( *t[1], *t[0] ) );
        swap_nodes_( t, 2, modifier_type::compare_( *t[0], *t[2] ) );
        
        if( W != store_.end( ) ) {
          std::unique_ptr<N*[]> st = modifier_type::split( t[0] );
          modifier_type::join_heaps( t[0], t[1], t[2]  );
          store_.insert( E, t[0]  );
          
          if( W->size( ) <= 1 ) { join_policy_.pop_lo( ); }
          update_lo_( E );
          
          store_.insert( W, st[0] ); store_.insert( W, st[1] );
          if( W->size( ) >= 3 ) { join_policy_.push_hi( W ); }
        } else {
          modifier_type::join_heaps( t[0], t[1], t[2]  );
          store_.insert( E, t[0] );
                    
          update_lo_( E );
        }
        join_policy_.push_lo( I );
      }

      /**
       * unfix_()
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::unfix_( )
      { }

      // swap aux
      template <typename N, typename M, typename S, typename J>
      void  root_registry<N, M, S, J>::swap_nodes_ (N* nodes[], int i1, int i2) {
        N* temp   = nodes[i1];
        nodes[i1] = nodes[i2];
        nodes[i2] = temp;
      }

      template <typename N, typename M, typename S, typename J>
      void  root_registry<N, M, S, J>::update_lo_ ( iterator_type E ) {
        if( E->size( )  == 1 && join_policy_.lo_empty( )  ) { 
          //P.push_lo( E ); 
        } else if( E->size( ) == 2 ) { 
          //P.pop_lo( ); 
        } else if( E->size( ) == 3 ) { join_policy_.push_hi( E ); }
      }

      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::print( ) const
      {
        store_.print( );
        join_policy_.print( );
      }

    }
  }
}
