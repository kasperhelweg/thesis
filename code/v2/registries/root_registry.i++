namespace KHJ  {
  namespace thesis  {
    namespace registry  {
      /**
       * Constructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      root_registry<N, M, S, J>::root_registry( ) : policy_( store_ )
      { }

      /**
       * DeConstructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      root_registry<N, M, S, J>::~root_registry( ) 
      { }
      
      /**
       * top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      N* root_registry<N, M, S, J>::top( ) const
      { 
        return store_.top; 
      }
      
      /**
       * insert( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::insert( N* Q )
      { 
        if( store_.top == nullptr || modifier_type::compare_( *Q, *store_.top ) ) { 
          store_.top = Q; 
        } store_.push_front( Q );
      }

      /**
       * extract( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      N* root_registry<N, M, S, J>::extract( )
      { 
        N* B = policy_.extract( );
        return B;
      }

      /**
       * consolidate( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::consolidate( )
      { 
        policy_.consolidate( );  
      }

      /**
       * update_top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::update_top( )
      { 
        // just set top to the first element.
        store_.top = nullptr;
        for( auto it = store_.begin( ) ; it != store_.end( ) ; it++ ) {
          for( auto vit = (*it).begin( ) ; vit != (*it).end( ) ; vit++ ) {
            if( store_.top == nullptr || modifier_type::compare_( (*(*vit)),  (*store_.top)  ))  {          
              store_.top = *vit;
            }
          }
        }
      }
       
      template<typename N, typename M, typename S, typename J>
      void root_registry<N, M, S, J>::print( ) const
      {
        store_.print( );
        std::cout << "top: " << (*store_.top).element( ) << std::endl;
      }
    }
  }
}
