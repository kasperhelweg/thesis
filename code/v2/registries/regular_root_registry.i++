namespace KHJ  {
  namespace thesis  {
    namespace root_registry  {
      /**
       * Constructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      regular_root_registry<N, M, S>::regular_root_registry( ) : size_( 0 ), top_( nullptr ), root_table_( ), hi_( ), wall_( )
      { }

      /**
       * DeConstructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      regular_root_registry<N, M, S>::~regular_root_registry( ) 
      { }
      
      /**
       * top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      N* regular_root_registry<N, M, S>::top( ) const
      { 
        return top_; 
      }

      /**
       * size( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      int regular_root_registry<N, M, S>::size( ) const
      { 
        //return root_table_.size( ); 
        return size_; 
      }

      template<typename N, typename M, typename S>
      bool regular_root_registry<N, M, S>::empty( ) const
      { 
        //return root_table_.size_ == 0;
        return size_ == 0;
      }
      
      /**
       * insert( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void regular_root_registry<N, M, S>::inject( N* Q )
      { 
        I k = root_table_.end( );
        I j = root_table_.end( );
        
        if( !wall_.empty( ) ) k = wall_.front( );
        if( !hi_.empty( ) )   j = hi_.front( );   
        if( (j != root_table_.end( ) && j != k ) && 
            ( k == root_table_.end( ) || (*j).p_ < (*k).p_ ) ) {
          transfer_( j, Q ); j++;
          if( (*j).size( ) == 2  ) 
            hi_.push_front( j );
          reduce_( j );
          if( (*(*j).begin( )).b_ > 0 ) 
            wall_.push_front( j );
          if( (*--j).size_ == 0 && j != root_table_.begin( ) )
            root_table_.shrink( j );
        } else {
          root_table_.inject( Q );
          if( k != root_table_.end( ) ) {
            reduce_( k );
            if( (*(*k).begin( )).b_ == 0 )
              wall_.pop_front( );
          }
          if( (*root_table_.begin( )).size( ) == 2  ) 
            hi_.push_front( begin( ) );           
        }
        if( top_ == nullptr || 
            M::compare_( 
                        (*Q).element(), (*top_).element() ) ) { 
          top_ = Q; 
        }
        size_++;
      }
      
      /**
       * extract( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      N* regular_root_registry<N, M, S>::eject( )
      {
        N* B; I k; N** st; char s;
        I j = root_table_.begin( );
        
        if( (*j).size_ == 0 ) ++j;        
        if( !wall_.empty( ) && j == wall_.front( ) ) {
          reduce_( j );
          if( (*(*j).begin( )).b_ == 0 )
            wall_.pop_front( );
        }
        root_list_node l = root_table_.remove_root( j ); 
        B = l.hp_;
        if( j == hi_.front( ) )      
          hi_.pop_front( );
        if( !wall_.empty( ) && j  == wall_.front( ) ) 
          wall_.pop_front( );
        if( j != root_table_.begin( ) ) {
          k = --j; 
          if( (*++j).p_ - 1 > (*k).p_ ) 
            root_table_.test( j, (*j).p_ - 1 ); --j;
          st = M::split( l.hp_ ); 
          s = l.bittrace_ & (1 << 0);
          swap_nodes_( st, 0, s );
          root_table_.insert_root( j, st[1], nullptr, 0, 0 );       
          root_table_.insert_root( j, st[0], l.sp_, l.b_, l.bittrace_ >> 1 );       
      
          delete[] st; hi_.push_front( j );   
          if( (*(*j).begin( )).b_ > 0 ) 
            wall_.push_front( j );
          if( (*++j).size_ == 0  )
            root_table_.shrink( j );
        }
        //root_table_.size_--;
        size_--;
        return B;
      }
      
      /**
       * consolidate( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void regular_root_registry<N, M, S>::transfer_( I j, N* Q )
      {
        I k = std::next( j ); 
        if( (*k).p_ != (*j).p_ + 1 ) { 
          root_table_.test( k, (*j).p_ + 1 ); --k;
        }        
        root_list_node l0 = root_table_.remove_root( j ); 
        root_list_node l1 = root_table_.remove_root( j );
        
        M::join_heaps( Q, l0.hp_, l1.hp_ );        
        root_table_.insert_root( k, Q, Q, (*j).p_ + 1, 0 );       
        hi_.pop_front( );
      }
      
      template<typename N, typename M, typename S>
      void regular_root_registry<N, M, S>::reduce_( I p )
      {
        RLI l = (*p).begin( );  
        unsigned short lvl = (*p).p_ - (*l).b_; 
              
        if( (*l).sp_ != nullptr ) {
          char d = M::incremental_siftdown( (*l).sp_ ); 
          if( d != -1 ) {
            (*l).bittrace_ |= d << lvl;
            if( lvl == 0 )
              (*l).hp_ = (*(*l).sp_).parent( );
          } else {
            (*l).sp_ = nullptr; 
            (*l).bittrace_ = 0;
          }
        }
        (*l).b_--;
      }
      
      /**
       * update_top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void regular_root_registry<N, M, S>::update_top( )
      {
        top_ = nullptr;
        for( auto it = root_table_.begin( ) ; it != root_table_.end( ) ; it++ ) {
          for( auto vit = (*it).begin( ) ; vit != (*it).end( ) ; vit++ ) {
            if( top_ == nullptr || 
                M::compare_( (*vit).hp_->element(),  (*top_).element() ) )  {          
              top_ = (*vit).hp_; } } 
        }
      }

      template<typename N, typename M, typename S>
      void regular_root_registry<N, M, S>::update_top( N* Q )
      {
        top_ = Q;
      }
       
      template<typename N, typename M, typename S>
      void regular_root_registry<N, M, S>::print( ) const
      {
        root_table_.print( );
        std::cout << "--------------" << std::endl;
        for( auto it = hi_.begin( ); it != hi_.end( ); ++it){
          std::cout << "hi: "  << (*(*it)).p_ << " ";
        }
        std::cout << std::endl;
        std::cout << "--------------" << std::endl;
        for( auto it = wall_.begin( ); it != wall_.end( ); ++it){
          std::cout << "wall: "  << (*(*it)).p_ << " ";
          
        }
        std::cout << std::endl;
        std::cout << "--------------" << std::endl;
        
      }

      // swap aux
      template <typename N, typename M, typename S>
      void regular_root_registry<N, M, S>::swap_nodes_ (N* nodes[], int i1, int i2) 
      {
        N* temp   = nodes[i1];
        nodes[i1] = nodes[i2];
        nodes[i2] = temp;
      }
    }
  }
}
