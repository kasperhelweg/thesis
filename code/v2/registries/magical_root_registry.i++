namespace KHJ  {
  namespace thesis  {
    namespace root_registry  {
      /**
       * Constructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      magical_root_registry<N, M, S>::magical_root_registry( ) 
      { 
        state_.reserve( 2 );
        state_[0] = root_table_.begin( );
        state_[1] = std::next( state_[0] );
        lo_.push_back( root_table_.begin( ) );
      }

      /**
       * DeConstructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      magical_root_registry<N, M, S>::~magical_root_registry( ) 
      { }
      
      /**
       * top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      N* magical_root_registry<N, M, S>::top( ) const
      { 
        return root_table_.top; 
      }

      /**
       * size( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      int magical_root_registry<N, M, S>::size( ) const
      { 
        return root_table_.size( ); 
      }

      
      /**
       * insert( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void magical_root_registry<N, M, S>::insert( N* Q )
      { 
        if( root_table_.top == nullptr || 
            modifier_type::compare_( (*Q).element(), (*root_table_.top).element() ) ) { 
          root_table_.top = Q; 
        } 
        root_table_.push_front( Q );

        if( (*root_table_.begin( )).size( ) == 2 ) { 
          lo_.pop_back( ); 
        } else if( (*root_table_.begin( )).size( ) == 3 ) { 
          hi_.push_back( root_table_.begin( ) ); 
        }
        if( !hi_.empty( ) ) {
          iterator_type I = hi_.back( ); hi_.pop_back( );
          fix_( I );
        }       
      }

      /**
       * extract( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      N* magical_root_registry<N, M, S>::extract( )
      { 
        N* B;
    
        if( root_table_.size( ) == 4 ) {
          iterator_type I = root_table_.begin( );
          B = root_table_.extract( std::next( I ) );
          N** st = modifier_type::split( B );
          root_table_.insert( I, st[0] ); root_table_.insert( I, st[1] ); 
        } else if(  root_table_.size( ) <= 3 ) {
          iterator_type I = root_table_.begin( );
          B   = root_table_.extract( I );
        } else {
          iterator_type I = root_table_.begin( );
          if( !in_idle_state_( ) && !lo_.empty( ) ) {
            if( state_[0]->size( ) == 2 && state_[1]->size( ) == 2) {
              if( !hi_.empty( ) && hi_[hi_.size( ) - 1]->size( ) == 3) {
                iterator_type L = lo_.back( ); lo_.pop_back( );
                unfix_( L );
              }
            } else {
              iterator_type L = lo_.back( ); lo_.pop_back( );
              unfix_( L );
            }
          }
          B = root_table_.extract( I );
          if( !I->empty( ) && I->size( ) == 2 ) {  hi_.pop_back( );
            // Valgrind reports Invalid Read... likely cause is:  lo_[lo_.size( ) - 1]
          } else if( ( I->empty( ) || ( !I->empty() && I->size( ) == 1 )) && ( lo_[lo_.size( ) - 1]  != I ) ) {
            lo_.push_back( I );
          }
        }
        
        return B;
      }

      /**
       * consolidate( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void magical_root_registry<N, M, S>::consolidate( )
      { 
        return;
      }

      /**
       * update_top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename M, typename S>
      void magical_root_registry<N, M, S>::update_top( )
      { 
        root_table_.top = nullptr;
        for( auto it = root_table_.begin( ) ; it != root_table_.end( ) ; it++ ) {
          for( auto vit = (*it).begin( ) ; vit != (*it).end( ) ; vit++ ) {
            if( root_table_.top == nullptr || 
                modifier_type::compare_( (*(*vit)).element(),  (*root_table_.top).element() ) )  {          
              root_table_.top = *vit;
            }
          }
        }
      }
       
      template<typename N, typename M, typename S>
      void magical_root_registry<N, M, S>::print( ) const
      {
        root_table_.print( );
        if( root_table_.top != nullptr ) {
          std::cout << "top: " << (*root_table_.top).element( ) << std::endl;
        }
      }
      
      template <typename N, typename M, typename S>
      void magical_root_registry<N, M, S>::fix_( iterator_type I )
      { 
        iterator_type E = std::next( I );  
        iterator_type W = std::prev( I );

        if( E == root_table_.end( ) ) { root_table_.grow( ); --E; }

        N* Q = root_table_.extract( I );
        N* R = root_table_.extract( I );
        N* V = root_table_.extract( I );
        
        N* t[3] =  { Q, R, V };     
        swap_nodes_( t, 0, modifier_type::compare_( (*t[1]).element(), (*t[0]).element() ) );
        swap_nodes_( t, 2, modifier_type::compare_( (*t[0]).element(), (*t[2]).element() ) );
        
        if( I != root_table_.begin( ) ) {
          N** st = modifier_type::split( t[0] );
          modifier_type::join_heaps( t[0], t[1], t[2]  ); root_table_.insert( E, t[0]  );
          
          if( !W->empty( ) && W->size( ) < 2 ) lo_.pop_back( );
          update_lo_( E );
          
          root_table_.insert( W, st[0] ); root_table_.insert( W, st[1] );
          if( W->size( ) > 2 ) hi_.push_back( W );
          
          delete[] st;
        } else {
          modifier_type::join_heaps( t[0], t[1], t[2]  ); root_table_.insert( E, t[0] );
          update_lo_( E );
        }
        lo_.push_back( I );
      
      }

      template <typename N, typename M, typename S>
      void magical_root_registry<N, M, S>::unfix_( iterator_type I )
      { 
        iterator_type E = std::next( I );
        iterator_type W = std::prev( I );
        
        N* P   = root_table_.extract( E );
        N** st = modifier_type::split( P );
        
        if( E->empty( ) && E == root_table_.last( ) ) {
          lo_.pop_back( ); root_table_.shrink( );
        } else {          
          if( !E->empty( ) && E->size( ) == 1 ) {
            lo_.push_back( E );
          } else if( !E->empty( ) && E->size( ) == 2 ){
            hi_.pop_back( );
          }
        }
        if( I != root_table_.begin( ) ) {
          if( !W->empty( ) && W->size( ) >= 3 ) hi_.pop_back( ); 
          
          N* Q = root_table_.extract( W );
          N* R = root_table_.extract( W );
          
          if( !W->empty( ) && W->size( ) <= 1 && W != root_table_.begin( ) ) lo_.push_back( W ); 
         
          modifier_type::join_heaps( P, Q, R  );
          modifier_type::siftdown( P );
          if( !(P->is_root( )) ) { P = P->find_root( ); }
          P = P->find_root( ); 
        }

        root_table_.insert( I, P ); root_table_.insert( I, st[0] ); root_table_.insert( I, st[1] );
        hi_.push_back( I );       
        delete[] st;
      }

      
      template<typename N, typename M, typename S>
      bool magical_root_registry<N, M, S>::in_idle_state_( ) const
      { 
        if( state_[0]->size() == 2 && state_[1]->size() == 1) { 
          return true;
        } else if( state_[0]->size( ) == 1 && state_[1]->size( ) == 2) {
          if( lo_.size( ) == 1 || lo_[lo_.size( ) - 2] == root_table_.last( ) ) {            
            return true;
          }
        }
        return false;
      }

      template <typename N, typename M, typename S>
      void magical_root_registry<N, M, S>::update_lo_( iterator_type E ) 
      {
        if( E->size( ) == 1 && lo_.empty( ) ) { 
          lo_.push_back( E );
        } else if( E->size( ) == 2 ) { 
          lo_.pop_back( ); 
        } else if( E->size( ) == 3 ) { 
          hi_.push_back( E ); 
        } 
      }
      
      // swap aux
      template <typename N, typename M, typename S>
      void magical_root_registry<N, M, S>::swap_nodes_ (N* nodes[], int i1, int i2) 
      {
        N* temp   = nodes[i1];
        nodes[i1] = nodes[i2];
        nodes[i2] = temp;
      }
    }
  }
}
