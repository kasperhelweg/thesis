namespace KHJ  {
  namespace thesis  {
    namespace store {
      
      /**
       * Constructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N>
      paper_store<N>::paper_store( ) : top_( nullptr )
      {
        root_store s; s.reserve( 4 );
        store_.push_back( s );
      }

      /**
       * DeConstructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N>
      paper_store<N>::~paper_store( ) 
      { }

      /**
       * top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N>
      N* paper_store<N>::top( ) const
      { 
        return top_;
      }

      /**
       * push_front( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N>
      typename paper_store<N>::join_schedule paper_store<N>::push_front( N* S ) 
      { 
        root_store* F = &store_.front( );
        (*F).push_back( S );
                
        //lo_.push_back( C( store_.begin( ), *this ) );
        
        //if( (*F).size( ) == 2 ) { lo_.pop_back( ); 
        //}         
        if( (*F).size( ) == 3 ) { hi_.push_back( store_.begin( ) ); 
        } 
        return join_schedule_( );
      }

      /**
       * pop_front( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N>
      N* paper_store<N>::pop_front( ) 
      { 
      }

      /**
       * insert( I position )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N>
      void paper_store<N>::insert( accessor_type position, N* S )
      { 
        if( !is_valid( position ) ) {
          grow_( position ); (*std::prev(position)).push_back( S );
        } else {
          (*position).push_back( S );
        }
      }

      /**
       * extract( I position )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N>
      N* paper_store<N>::extract( accessor_type position )
      { 
        N* S = position->back( ); position->pop_back( );
        return S;
      }

      /** public auxiliary **/
      
      template<typename N>
      bool paper_store<N>::is_valid( accessor_type position ) const
      { 
        return position != store_.end( );
      }

      template<typename N>
      int paper_store<N>::size_of( accessor_type position ) const
      { 
        return position->size( );
      }

      /** private auxiliary **/

      // grow_( ).
      
      template <typename N>
      void paper_store<N>::grow_( accessor_type position ) 
      { 
        root_store s; s.reserve( 4 );
        store_.push_back( s );
      }

      // shrink_( ).
      
      template <typename N>
      void paper_store<N>::shrink_( accessor_type position ) 
      { 
        store_.erase( position );
      }


      /** join_schedule **/

      template<typename N>
      void paper_store<N>::push_hi( accessor_type position )
      { 
        hi_.push_back( position );
      }

      template<typename N>
      void paper_store<N>::pop_hi( )
      { 
        hi_.pop_back( );
      }
      
      template<typename N>
      void paper_store<N>::push_lo( accessor_type position )
      { 
        lo_.push_back( position );
      }

      template<typename N>
      void paper_store<N>::pop_lo( )
      { 
        lo_.pop_back( );
      }

      template<typename N>
      typename paper_store<N>::join_schedule paper_store<N>::join_schedule_( )
      {
        join_schedule v = { };
        if( !hi_.empty( ) ) {
          v.push_back( hi_.back( ) ); hi_.pop_back( );
        } 
        return v; 
      }
      
      template<typename N>
      void paper_store<N>::print( ) const
      { 
        std::cout << "-----------------" << std::endl ;
        for( auto it = store_.begin( ); it != store_.end( ); ++it) {
          std::cout << (*it).size( ) << " " ;
        } 
        std::cout << std::endl;
        std::cout << "-----------------" << std::endl ; 
        std::cout << "hi: ";
        if( !hi_.empty( )) {
          for( auto it = hi_.begin( ); it != hi_.end( ); ++it) {
            std::cout << (*(*it)).size( ) << " " ;
          }
        } else {
          std::cout << "empty";
        } 
        std::cout << std::endl;
        /*
        std::cout << "-----------------" << std::endl ; 
        std::cout << "lo: ";
        if( !lo_.empty( )) {
          for( auto it = lo_.begin( ); it != lo_.end( ); ++it) {
            std::cout << (*(*it).accessor( )).size( ) << " " ;
          }
         
        } else {
          std::cout << "empty";
        }
        */
        std::cout << std::endl << std::endl ;     
      }
    }
  }
}
