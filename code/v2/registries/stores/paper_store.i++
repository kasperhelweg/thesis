namespace KHJ  {
  namespace thesis  {
    namespace store {
      
      /**
       * Constructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename C>
      paper_store<N, C>::paper_store( ) : top_( nullptr ), compare_( C( ) )
      {
        root_store f; f.reserve( 4 ); store_.push_back( f );
        root_store s; s.reserve( 4 ); store_.push_back( s );
      }

      /**
       * DeConstructor.
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename C>
      paper_store<N, C>::~paper_store( ) 
      { }

      /**
       * top( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename C>
      N* paper_store<N, C>::top( ) const
      { 
        return top_;
      }

      /**
       * push_front( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename C>
      void paper_store<N, C>::push_front( N* S ) 
      { 
        (*(begin( ))).push_back( S );
        if( top_ == nullptr || compare_( *S, *top_ ) ) {
          top_ = S;
        }
      }

      /**
       * pop_front( )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename C>
      N* paper_store<N, C>::pop_front( ) 
      { 
        return (*(begin( ))).pop_back( );
      }

      /**
       * insert( I position )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename C>
      void paper_store<N, C>::insert( iterator_type position, N* S )
      { 
        (*position).push_back( S );
      }

      /**
       * extract( I position )
       * 
       * complexity is (probably) O(1)
       * @author KHJ
       *
       */
      template<typename N, typename C>
      N* paper_store<N, C>::extract( iterator_type position )
      {
        N* S = position->back( ); position->pop_back( );
        return S;
      }
      
      /** private auxiliary **/

      // grow_( ).
      
      template <typename N, typename C>
      void paper_store<N, C>::grow( ) 
      { 
        root_store s; s.reserve( 4 );
        store_.push_back( s );
      }

      // shrink_( ).
      
      template <typename N, typename C>
      void paper_store<N, C>::shrink(  ) 
      { 
        store_.pop_back( );;
      }
      
      template<typename N, typename C>
      void paper_store<N, C>::print( ) const
      { 
        std::cout << "-----------------" << std::endl ;
        for( auto it = store_.begin( ); it != store_.end( ); ++it) {
          std::cout << (*it).size( ) << " " ;
        } 
        std::cout << std::endl;     
      }
    }
  }
}
