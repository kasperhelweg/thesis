namespace KHJ  {
  namespace thesis  {
    namespace queue  {

      template<typename E, typename N, typename R, typename A>
      E binary_queue<E, N, R, A>::top(  ) 
      {
        N* S = registry_.top( );
        return S->element( );
      }

      template<typename E, typename N, typename R, typename A>
      N* binary_queue<E, N, R, A>::push( const E& val ) 
      {
        N* S = buy_node_( val );
        
        registry_.insert( S );
        registry_.consolidate( );

        return S;
      }
    
      template<typename E, typename N, typename R, typename A>
      E binary_queue<E, N, R, A>::pop( ) 
      {
        N* S = registry_.extract( registry_.top( ) );
        E val = S->element( ); sell_node_( S );

        return val;
      }

      template<typename E, typename N, typename R, typename A>
      void binary_queue<E, N, R, A>::erase( N* P ) 
      {
        N* S = registry_.extract( P );
        sell_node_( S );
      }

      // Buy a node. Heap memory is the currency.
      template<typename E, typename N, typename R, typename A>
      N* binary_queue<E, N, R, A>::buy_node_( const E& val ) 
      {
        N* S = allocator_.allocate( 1 );
        try {
          allocator_.construct( S, N( val ) );
        }
        catch(...) {
          allocator_.deallocate( S, 1 );
          throw;
        }
        return S;
      }
   
      template<typename E, typename N, typename R, typename A>
      void binary_queue<E, N, R, A>::sell_node_( N* S ) 
      {
        allocator_.destroy( S ); allocator_.deallocate( S, 1 ); 
        S = nullptr;
      }
    }
  }
}
